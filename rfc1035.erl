%%% Do not modify this file, it is automatically generated by abnfc.
%%% All changes will be lost when it is regenerated.
%%% Generated by abnfc_gen on 2011-08-27 21:49:12

-module(rfc1035).

-export([decode/2, 'do-main'/0, label/0, 'ldh-str'/0,
	 'let-dig'/0, 'let-dig-hyp'/0, subdomain/0]).

-include("rfc1035.hrl").

decode('do-main', Str) -> ('do-main'())(Str);
decode(subdomain, Str) -> (subdomain())(Str);
decode(label, Str) -> (label())(Str);
decode('ldh-str', Str) -> ('ldh-str'())(Str);
decode('let-dig-hyp', Str) -> ('let-dig-hyp'())(Str);
decode('let-dig', Str) -> ('let-dig'())(Str).

'do-main'() ->
    fun (T) ->
	    __P = '__alt'([fun ([C | Tl]) when C == 32 ->
				   {ok, C, Tl};
			       (_) -> fail
			   end,
			   subdomain()]),
	    __P(T)
    end.

subdomain() ->
    fun (T) ->
	    __P = '__seq'([label(),
			   '__repeat'(0, infinity,
				      '__seq'([fun ([46 | Tl]) -> {ok, 46, Tl};
						   (_) -> fail
					       end,
					       label()]))]),
	    __P(T)
    end.

label() ->
    fun (T) ->
	    __P = '__seq'(['ALPHA'(),
			   '__repeat'(0, infinity, 'ldh-str'()),
			   '__repeat'(1, infinity, 'let-dig'())]),
	    __P(T)
    end.

'ldh-str'() ->
    fun (T) ->
	    __P = '__alt'(['__seq'(['let-dig-hyp'(), 'ldh-str'()]),
			   'let-dig-hyp'()]),
	    __P(T)
    end.

'let-dig-hyp'() ->
    fun (T) ->
	    __P = '__alt'([fun ([C | Tl]) when C == 45 ->
				   {ok, C, Tl};
			       (_) -> fail
			   end,
			   'let-dig'()]),
	    __P(T)
    end.

'let-dig'() ->
    fun (T) -> __P = '__alt'(['ALPHA'(), 'DIGIT'()]), __P(T)
    end.

'__alt'([P | Ps]) ->
    fun (T) ->
	    case P(T) of
	      {ok, _R, _T1} = Res -> Res;
	      fail ->
		  case Ps of
		    [] -> fail;
		    _ -> ('__alt'(Ps))(T)
		  end
	    end
    end.

'__repeat'(Min, Max, P) -> '__repeat'(Min, Max, P, 0).

'__repeat'(Min, Max, P, Found) ->
    fun (T) ->
	    case P(T) of
	      {ok, R1, T1} when Max == Found + 1 -> {ok, [R1], T1};
	      {ok, R1, T1} ->
		  case ('__repeat'(Min, Max, P, Found + 1))(T1) of
		    {ok, R2, T2} -> {ok, [R1 | R2], T2};
		    fail when Found >= Min -> {ok, [R1], T1};
		    fail -> fail
		  end;
	      fail when Found >= Min -> {ok, [], T};
	      fail -> fail
	    end
    end.

'__seq'([P | Ps]) ->
    fun (T) ->
	    case P(T) of
	      {ok, R1, T1} ->
		  case ('__seq'(Ps))(T1) of
		    {ok, R2, T2} -> {ok, [R1 | R2], T2};
		    fail -> fail
		  end;
	      fail -> fail
	    end
    end;
'__seq'([]) -> fun (T) -> {ok, [], T} end.
