%%% Do not modify this file, it is automatically generated by abnfc.
%%% All changes will be lost when it is regenerated.
%%% Generated by abnfc_gen on 2011-08-27 22:13:37

-module(ux_unicode_locale_identifier).

-export([alphanum/0, attribute/0, decode/2, key/0,
	 keyword/0, type/0, 'unicode-locale-extensions'/0,
	 'unicode-locale-id'/0]).

-include("ux_unicode_locale_identifier.hrl").

decode('unicode-locale-id', Str) ->
    ('unicode-locale-id'())(Str);
decode('unicode-locale-extensions', Str) ->
    ('unicode-locale-extensions'())(Str);
decode(keyword, Str) -> (keyword())(Str);
decode(key, Str) -> (key())(Str);
decode(type, Str) -> (type())(Str);
decode(attribute, Str) -> (attribute())(Str);
decode(alphanum, Str) -> (alphanum())(Str).

'unicode-locale-id'() ->
    fun (T) ->
	    __P = '__seq'(['unicode-language-id'(),
			   '__repeat'(0, 1, 'unicode-locale-extensions'())]),
	    __P(T)
    end.

'unicode-locale-extensions'() ->
    fun (T) ->
	    __P = '__seq'([sep(),
			   fun ([C | Tl]) when C == 117 -> {ok, C, Tl};
			       ([C | Tl]) when C == 85 -> {ok, C, Tl};
			       (_) -> fail
			   end,
			   '__alt'(['__repeat'(1, infinity,
					       '__seq'([sep(), keyword()])),
				    '__seq'(['__repeat'(1, infinity,
							'__seq'([sep(), attribute()])),
					     '__repeat'(0, infinity,
							'__seq'([sep(), keyword()]))])])]),
	    __P(T)
    end.

keyword() ->
    fun (T) ->
	    __P = '__seq'([key(),
			   '__repeat'(0, 1, '__seq'([sep(), type()]))]),
	    __P(T)
    end.

key() ->
    fun (T) -> __P = '__repeat'(2, 2, alphanum()), __P(T)
    end.

type() ->
    fun (T) -> __P = '__repeat'(3, 8, alphanum()), __P(T)
    end.

attribute() ->
    fun (T) -> __P = '__repeat'(3, 8, alphanum()), __P(T)
    end.

alphanum() ->
    fun (T) -> __P = '__alt'(['ALPHA'(), 'DIGIT'()]), __P(T)
    end.

'__alt'([P | Ps]) ->
    fun (T) ->
	    case P(T) of
	      {ok, _R, _T1} = Res -> Res;
	      fail ->
		  case Ps of
		    [] -> fail;
		    _ -> ('__alt'(Ps))(T)
		  end
	    end
    end.

'__repeat'(Min, Max, P) -> '__repeat'(Min, Max, P, 0).

'__repeat'(Min, Max, P, Found) ->
    fun (T) ->
	    case P(T) of
	      {ok, R1, T1} when Max == Found + 1 -> {ok, [R1], T1};
	      {ok, R1, T1} ->
		  case ('__repeat'(Min, Max, P, Found + 1))(T1) of
		    {ok, R2, T2} -> {ok, [R1 | R2], T2};
		    fail when Found >= Min -> {ok, [R1], T1};
		    fail -> fail
		  end;
	      fail when Found >= Min -> {ok, [], T};
	      fail -> fail
	    end
    end.

'__seq'([P | Ps]) ->
    fun (T) ->
	    case P(T) of
	      {ok, R1, T1} ->
		  case ('__seq'(Ps))(T1) of
		    {ok, R2, T2} -> {ok, [R1 | R2], T2};
		    fail -> fail
		  end;
	      fail -> fail
	    end
    end;
'__seq'([]) -> fun (T) -> {ok, [], T} end.
